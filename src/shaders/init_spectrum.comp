#version 460
#extension GL_EXT_buffer_reference2 : require

layout( local_size_x = 8, local_size_y = 8 ) in;
layout( rgba16f, set = 0, binding = 0 ) uniform image2D _InitialSpectrumTextures;

struct Spectrum {
	float scale;
	float angle;
	float spreadBlend;
	float swell;
	float alpha;
	float peakOmega;
	float gamma;
	float shortWavesFade;
};

layout( buffer_reference, std430 ) readonly buffer Spectrums {
    Spectrum data[];
};

layout( push_constant ) uniform Constants {
    Spectrums spectrums;
} push;

#define PI 3.14159265358979323846

const float _gravity = 9.81;
const float _depth = 20;
const float _low_cutoff = 0.0001;
const float _high_cutoff = 9000;

const int _Seed = 1;

const uint _N = 256;
const uint _length_scale_0 = 94;
const uint _length_scale_1 = 128; 
const uint _length_scale_2 = 64; 
const uint _length_scale_3 = 32;

float hash(uint n) {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x137631U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

vec2 UniformToGaussian(float u1, float u2) {
    float R = sqrt(-2.0f * log(u1));
    float theta = 2.0f * PI * u2;

    return vec2(R * cos(theta), R * sin(theta));
}

float Dispersion(float kMag) {
    return sqrt(_gravity * kMag * tanh(min(kMag * _depth, 20)));
}

float DispersionDerivative(float kMag) {
    float th = tanh(min(kMag * _depth, 20));
    float ch = cosh(kMag * _depth);
    return _gravity * (_depth * kMag / ch / ch + th) / Dispersion(kMag) / 2.0f;
}

float NormalizationFactor(float s) {
    float s2 = s * s;
    float s3 = s2 * s;
    float s4 = s3 * s;
    if (s < 5) return -0.000564f * s4 + 0.00776f * s3 - 0.044f * s2 + 0.192f * s + 0.163f;
    else return -4.80e-08f * s4 + 1.07e-05f * s3 - 9.53e-04f * s2 + 5.90e-02f * s + 3.93e-01f;
}

float DonelanBannerBeta(float x) {
	if (x < 0.95f) return 2.61f * pow(abs(x), 1.3f);
	if (x < 1.6f) return 2.28f * pow(abs(x), -1.3f);

	float p = -0.4f + 0.8393f * exp(-0.567f * log(x * x));
	return pow(10.0f, p);
}

float DonelanBanner(float theta, float omega, float peakOmega) {
	float beta = DonelanBannerBeta(omega / peakOmega);
	float sech = 1.0f / cosh(beta * theta);
	return beta / 2.0f / tanh(beta * 3.1416f) * sech * sech;
}

float Cosine2s(float theta, float s) {
	return NormalizationFactor(s) * pow(abs(cos(0.5f * theta)), 2.0f * s);
}

float SpreadPower(float omega, float peakOmega) {
	if (omega > peakOmega)
		return 9.77f * pow(abs(omega / peakOmega), -2.5f);
	else
		return 6.97f * pow(abs(omega / peakOmega), 5.0f);
}

float DirectionSpectrum(float theta, float omega, float spectrum_peak_omega, float spectrum_swell, float spectrum_angle, float spectrum_spread_blend) {
	float s = SpreadPower(omega, spectrum_peak_omega) + 16 * tanh(min(omega / spectrum_peak_omega, 20)) * spectrum_swell * spectrum_swell;
	return mix(2.0f / 3.1415f * cos(theta) * cos(theta), Cosine2s(theta - spectrum_angle, s), spectrum_spread_blend);
}

float TMACorrection(float omega) {
	float omegaH = omega * sqrt(_depth / _gravity);
	if (omegaH <= 1.0f)
		return 0.5f * omegaH * omegaH;
	if (omegaH < 2.0f)
		return 1.0f - 0.5f * (2.0f - omegaH) * (2.0f - omegaH);

	return 1.0f;
}

float JONSWAP(float omega, float spectrum_peak_omega, float spectrum_scale, float spectrum_alpha, float spectrum_gamma) {
	float sigma = (omega <= spectrum_peak_omega) ? 0.07f : 0.09f;

	float r = exp(-(omega - spectrum_peak_omega) * (omega - spectrum_peak_omega) / 2.0f / sigma / sigma / spectrum_peak_omega / spectrum_peak_omega);
	
	float oneOverOmega = 1.0f / omega;
	float peakOmegaOverOmega = spectrum_peak_omega / omega;
	return spectrum_scale * TMACorrection(omega) * spectrum_alpha * _gravity * _gravity
		* oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega
		* exp(-1.25f * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega)
		* pow(abs(spectrum_gamma), r);
}

float ShortWavesFade(float kLength, float spectrum_shortWavesFade) {
	return exp(-spectrum_shortWavesFade * spectrum_shortWavesFade * kLength * kLength);
}

void main() {
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    uint seed = id.x + _N * id.y + _N;
    seed += _Seed;

    float lengthScales[4] = { _length_scale_0, _length_scale_1, _length_scale_2, _length_scale_3 };

    for (uint i = 0; i < 4; ++i) {
        float halfN = _N / 2.0f;
        float deltaK = 2.0f * PI / lengthScales[i];
        vec2 K = (id.xy - halfN) * deltaK;
        float kLength = length(K);

        seed += i + uint(hash(seed)) * 10;
        vec4 uniformRandSamples = vec4(hash(seed), hash(seed * 2), hash(seed * 3), hash(seed * 4));
        vec2 gauss1 = UniformToGaussian(uniformRandSamples.x, uniformRandSamples.y);
        vec2 gauss2 = UniformToGaussian(uniformRandSamples.z, uniformRandSamples.w);

        if (_low_cutoff <= kLength && kLength <= _high_cutoff) {
            float kAngle = atan(K.y, K.x);
            float omega = Dispersion(kLength);

            float dOmegadk = DispersionDerivative(kLength);

            float spectrum = JONSWAP(omega, push.spectrums.data[i * 2].peakOmega, push.spectrums.data[i * 2].scale, push.spectrums.data[i * 2].alpha, push.spectrums.data[i * 2].gamma)
                * DirectionSpectrum(kAngle, omega, push.spectrums.data[i * 2].peakOmega, push.spectrums.data[i * 2].swell, push.spectrums.data[i * 2].angle, push.spectrums.data[i * 2].spreadBlend)
                * ShortWavesFade(kLength, push.spectrums.data[i * 2].shortWavesFade);
            
            if (push.spectrums.data[i * 2 + 1].scale > 0)
                spectrum += JONSWAP(omega, push.spectrums.data[i * 2 + 1].peakOmega, push.spectrums.data[i * 2 + 1].scale, push.spectrums.data[i * 2 + 1].alpha, push.spectrums.data[i * 2 + 1].gamma)
                    * DirectionSpectrum(kAngle, omega, push.spectrums.data[i * 2 + 1].peakOmega, push.spectrums.data[i * 2 + 1].swell, push.spectrums.data[i * 2 + 1].angle, push.spectrums.data[i * 2 + 1].spreadBlend) 
                    * ShortWavesFade(kLength, push.spectrums.data[i * 2 + 1].shortWavesFade);
            
            imageStore(_InitialSpectrumTextures, id.xy, vec4(vec2(gauss2.x, gauss1.y) * sqrt(2 * spectrum * abs(dOmegadk) / kLength * deltaK * deltaK), 0.0f, 0.0f));
        } else {
            imageStore(_InitialSpectrumTextures, id.xy, vec4(0));
        }
    }
}


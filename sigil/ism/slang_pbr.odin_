
package ism

import vk "vendor:vulkan"
import "core:math/linalg/glsl"
import "lib:odin-slang/slang"
import "core:slice"
import "core:fmt"
import "core:time"

//_____________________________
PBR_Material :: struct {
    color             : AllocatedImage,
    metal_roughness   : AllocatedImage,
    normal            : AllocatedImage,
    emissive          : AllocatedImage,
    ambient_occlusion : AllocatedImage,
    sampler           : vk.Sampler,
    data              : vk.Buffer,
    offset            : u32,
    set_layout        : vk.DescriptorSetLayout,
    set               : vk.DescriptorSet,
    pool              : vk.DescriptorPool,
    pipeline          : vk.Pipeline,
    pipeline_layout   : vk.PipelineLayout,
}
PBR_Uniform :: struct {
    color_factors           : glsl.vec4,
    metal_roughness_factors : glsl.vec4,
    padding                 : [14]glsl.vec4,
}
pbr_uniform := PBR_Uniform {
    color_factors           = { 1, 1, 1, 1 },
    metal_roughness_factors = { 1, 1, 1, 1 },
}

pbr_declare :: proc(global_session: ^slang.IGlobalSession) {

    pbr_layout_bindings := []vk.DescriptorSetLayoutBinding {
        vk.DescriptorSetLayoutBinding {
            binding         = 0,
            descriptorType  = .UNIFORM_BUFFER,
            descriptorCount = 1,
            stageFlags      = { .VERTEX, .FRAGMENT },
        },
        vk.DescriptorSetLayoutBinding {
            binding         = 1,
            descriptorType  = .COMBINED_IMAGE_SAMPLER,
            descriptorCount = 1,
            stageFlags      = { .VERTEX, .FRAGMENT },
        },
        vk.DescriptorSetLayoutBinding {
            binding         = 2,
            descriptorType  = .COMBINED_IMAGE_SAMPLER,
            descriptorCount = 1,
            stageFlags      = { .VERTEX, .FRAGMENT },
        },
        vk.DescriptorSetLayoutBinding {
            binding         = 3,
            descriptorType  = .COMBINED_IMAGE_SAMPLER,
            descriptorCount = 1,
            stageFlags      = { .VERTEX, .FRAGMENT },
        },
        vk.DescriptorSetLayoutBinding {
            binding         = 4,
            descriptorType  = .COMBINED_IMAGE_SAMPLER,
            descriptorCount = 1,
            stageFlags      = { .VERTEX, .FRAGMENT },
        },
        vk.DescriptorSetLayoutBinding {
            binding         = 5,
            descriptorType  = .COMBINED_IMAGE_SAMPLER,
            descriptorCount = 1,
            stageFlags      = { .VERTEX, .FRAGMENT },
        },
    }
    pbr_layout_info := vk.DescriptorSetLayoutCreateInfo {
        sType        = .DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        flags        = {},
        bindingCount = u32(len(pbr_layout_bindings)),
        pBindings    = raw_data(pbr_layout_bindings),
    }
    __ensure(
        vk.CreateDescriptorSetLayout(device, &pbr_layout_info, nil, &pbr.set_layout),
        msg = "Failed to create descriptor set"
    )

    pbr_allocate_info := vk.DescriptorSetAllocateInfo {
        sType              = .DESCRIPTOR_SET_ALLOCATE_INFO,
        descriptorPool     = desc_pool,
        descriptorSetCount = 1,
        pSetLayouts        = &pbr.set_layout,
    }
    __ensure(
        vk.AllocateDescriptorSets(device, &pbr_allocate_info, &pbr.set),
        msg = "Failed to allocate descriptor set"
    )

    pbr_push_const := vk.PushConstantRange {
        stageFlags = { .VERTEX, .FRAGMENT },
        offset     = 0,
        size       = size_of(GPU_PushConstants),
    }
    layouts := []vk.DescriptorSetLayout {
        scene_data.set_layout,
        pbr.set_layout
    }
    pipeline_layout_info := vk.PipelineLayoutCreateInfo {
        sType                  = .PIPELINE_LAYOUT_CREATE_INFO,
        setLayoutCount         = u32(len(layouts)),
        pSetLayouts            = raw_data(layouts),
        pushConstantRangeCount = 1,
        pPushConstantRanges    = &pbr_push_const,
    }
    __ensure(
        vk.CreatePipelineLayout(device, &pipeline_layout_info, nil, &pbr.pipeline_layout),
        msg = "Failed to create graphics pipeline layout"
    )

    pbr_buffer := create_buffer(size_of(PBR_Uniform), { .UNIFORM_BUFFER }, .CPU_TO_GPU)
    {
        pbr_buffer_data := cast(^PBR_Uniform)pbr_buffer.info.pMappedData
        pbr_buffer_data.color_factors           = { 1, 1, 1, 1 }
        pbr_buffer_data.metal_roughness_factors = { 1, 1, 1, 1 }
    }
    color_img     := load_image(.R8G8B8A8_UNORM, { .SAMPLED }, "res/textures/Default_albedo.jpg")
    mtl_rough_img := load_image(.R8G8B8A8_UNORM, { .SAMPLED }, "res/textures/Default_metalRoughness.jpg")
    normal_img    := load_image(.R8G8B8A8_UNORM, { .SAMPLED }, "res/textures/Default_normal.jpg")
    emissive_img  := load_image(.R8G8B8A8_UNORM, { .SAMPLED }, "res/textures/Default_emissive.jpg")
    ao_img        := load_image(.R8G8B8A8_UNORM, { .SAMPLED }, "res/textures/Default_AO.jpg")
    
    desc := DescriptorData { set = pbr.set }
    pbr_writes := []vk.WriteDescriptorSet {
        write_descriptor(&desc, 0, .UNIFORM_BUFFER, DescriptorBufferInfo { pbr_buffer, size_of(PBR_Uniform), 0 }),
        write_descriptor(&desc, 1, .COMBINED_IMAGE_SAMPLER, DescriptorImageInfo { color_img.view,     sampler, .SHADER_READ_ONLY_OPTIMAL }),
        write_descriptor(&desc, 2, .COMBINED_IMAGE_SAMPLER, DescriptorImageInfo { mtl_rough_img.view, sampler, .SHADER_READ_ONLY_OPTIMAL }),
        write_descriptor(&desc, 3, .COMBINED_IMAGE_SAMPLER, DescriptorImageInfo { normal_img.view,    sampler, .SHADER_READ_ONLY_OPTIMAL }),
        write_descriptor(&desc, 4, .COMBINED_IMAGE_SAMPLER, DescriptorImageInfo { emissive_img.view,  sampler, .SHADER_READ_ONLY_OPTIMAL }),
        write_descriptor(&desc, 5, .COMBINED_IMAGE_SAMPLER, DescriptorImageInfo { ao_img.view,        sampler, .SHADER_READ_ONLY_OPTIMAL }),
    }
    vk.UpdateDescriptorSets(device, u32(len(pbr_writes)), raw_data(pbr_writes), 0, nil)

    rebuild_pipeline(global_session)
}

rebuild_pipeline :: proc(global_session: ^slang.IGlobalSession) {
	start_compile_time := time.tick_now()
    //
    using slang
	code, diagnostics: ^IBlob
	r: Result

	target_desc := TargetDesc {
		structureSize = size_of(TargetDesc),
		format        = .SPIRV,
		flags         = { .GENERATE_SPIRV_DIRECTLY },
		profile       = global_session->findProfile("sm_6_0"),
	}

	compiler_option_entries := [?]CompilerOptionEntry{
		{name = .VulkanUseEntryPointName, value = {intValue0 = 1}},
	}
	session_desc := SessionDesc {
		structureSize            = size_of(SessionDesc),
		targets                  = &target_desc,
		targetCount              = 1,
		compilerOptionEntries    = &compiler_option_entries[0],
		compilerOptionEntryCount = 1,
	}

	session: ^ISession
	__ensure(global_session->createSession(session_desc, &session))
	defer session->release()

	blob: ^IBlob

	module: ^IModule = session->loadModule("sigil/ism/shaders/pbr.slang", &diagnostics)
	if module == nil {
		fmt.println("Shader compile error!")
		return
	}
	defer module->release()
	diagnostics_check(diagnostics)

	vertex_entry: ^IEntryPoint
	module->findEntryPointByName("vsmain", &vertex_entry)

	fragment_entry: ^IEntryPoint
	module->findEntryPointByName("fsmain", &fragment_entry)

	if vertex_entry == nil {
		fmt.println("Expected 'vertex' entry point")
		return;
	}
	if fragment_entry == nil {
		fmt.println("Expected 'fragment' entry point")
		return;
	}

	components: [3]^IComponentType = { module, vertex_entry, fragment_entry }

	linked_program: ^IComponentType
	r = session->createCompositeComponentType(
		&components[0],
		len(components),
		&linked_program,
		&diagnostics,
	)
	diagnostics_check(diagnostics)
	__ensure(r)

	target_code: ^IBlob
	r = linked_program->getTargetCode(0, &target_code, &diagnostics)
	diagnostics_check(diagnostics)
	__ensure(r)

	code_size := target_code->getBufferSize()
	source_code := slice.bytes_from_ptr(target_code->getBufferPointer(), auto_cast code_size)

	info := vk.ShaderModuleCreateInfo {
		sType    = .SHADER_MODULE_CREATE_INFO,
		codeSize = len(source_code), // codeSize needs to be in bytes
		pCode    = raw_data(slice.reinterpret([]u32, source_code)), // code needs to be in 32bit words
	}

	vk_module: vk.ShaderModule
	__ensure(vk.CreateShaderModule(device, &info, nil, &vk_module))
    defer vk.DestroyShaderModule(device, vk_module, nil)

	// Create pipelines and pipeline layouts
    pbr_push_const := vk.PushConstantRange {
        stageFlags = { .VERTEX, .FRAGMENT },
        offset     = 0,
        size       = size_of(GPU_PushConstants),
    }
    layouts := []vk.DescriptorSetLayout {
        scene_data.set_layout,
        pbr.set_layout
    }
    pipeline_layout_info := vk.PipelineLayoutCreateInfo {
        sType                  = .PIPELINE_LAYOUT_CREATE_INFO,
        setLayoutCount         = u32(len(layouts)),
        pSetLayouts            = raw_data(layouts),
        pushConstantRangeCount = 1,
        pPushConstantRanges    = &pbr_push_const,
    }
    __ensure(
        vk.CreatePipelineLayout(device, &pipeline_layout_info, nil, &pbr.pipeline_layout), 
        msg = "Failed to create graphics pipeline layout"
    )

	pipeline_layout_create_info := vk.PipelineLayoutCreateInfo {
		sType                  = .PIPELINE_LAYOUT_CREATE_INFO,
		pNext                  = nil,
		flags                  = {},
		setLayoutCount         = u32(len(layouts)),
		pSetLayouts            = raw_data(layouts),
		pushConstantRangeCount = 1,
		pPushConstantRanges    = &pbr_push_const,
	}

	if pbr.pipeline_layout != 0 {
		vk.DestroyPipelineLayout(device, pbr.pipeline_layout, nil)
	}
	__ensure(
        vk.CreatePipelineLayout(device, &pipeline_layout_create_info, nil, &pbr.pipeline_layout),
        msg = "Failed to create pipeline layout"
    )

	pipelineInfo := vk.GraphicsPipelineCreateInfo {
		sType               = .GRAPHICS_PIPELINE_CREATE_INFO,
		pNext               = &vk.PipelineRenderingCreateInfo {
			sType                   = .PIPELINE_RENDERING_CREATE_INFO,
			colorAttachmentCount    = 1,
			pColorAttachmentFormats = &draw_img.format,
			depthAttachmentFormat   = depth_img.format,
		},
		pStages             = raw_data(
			[]vk.PipelineShaderStageCreateInfo {
				{
					sType = .PIPELINE_SHADER_STAGE_CREATE_INFO,
					stage = {.VERTEX},
					module = vk_module,
					pName = "vsmain",
				},
				{
					sType = .PIPELINE_SHADER_STAGE_CREATE_INFO,
					stage = {.FRAGMENT},
					module = vk_module,
					pName = "fsmain",
				},
			},
		),
		stageCount          = 2,
		pVertexInputState   = &{ sType = .PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO },
		pInputAssemblyState = &{
			sType                  = .PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
			topology               = .TRIANGLE_LIST,
			primitiveRestartEnable = false,
		},
		pViewportState      = &{
			sType         = .PIPELINE_VIEWPORT_STATE_CREATE_INFO,
			viewportCount = 1,
			scissorCount  = 1,
		},
		pRasterizationState = &{
			sType       = .PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
			polygonMode = .FILL,
			lineWidth   = 1,
			frontFace   = .CLOCKWISE,
		},
		pMultisampleState   = &{
			sType                   = .PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
			sampleShadingEnable     = false,
			rasterizationSamples    = { ._1 },
			minSampleShading        = 1.0,
			pSampleMask             = nil,
			alphaToCoverageEnable   = false,
			alphaToOneEnable        = false,
		},
		pColorBlendState    = &{
			sType            = .PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
			logicOpEnable    = false,
			logicOp          = .COPY,
			attachmentCount  = 1,
			pAttachments     = &vk.PipelineColorBlendAttachmentState {
				colorWriteMask      = { .R, .G, .B, .A },
				blendEnable         = false,
                //srcColorBlendFactor = .SRC_ALPHA,
                //dstColorBlendFactor = .ONE_MINUS_SRC_ALPHA,
                //colorBlendOp        = .ADD,
                //srcAlphaBlendFactor = .ONE,
                //dstAlphaBlendFactor = .ZERO,
                //alphaBlendOp        = .ADD,
			},
		},
		pDepthStencilState  = &{
			sType                 = .PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
			depthTestEnable       = true,
			depthWriteEnable      = true,
			depthCompareOp        = .GREATER_OR_EQUAL,
			depthBoundsTestEnable = false,
			stencilTestEnable     = false,
			front                 = {},
			back                  = {},
			minDepthBounds        = 0.0,
			maxDepthBounds        = 1.0,
		},
		layout              = pbr.pipeline_layout,
		pDynamicState       = &{
			sType             = .PIPELINE_DYNAMIC_STATE_CREATE_INFO,
			pDynamicStates    = raw_data([]vk.DynamicState { .VIEWPORT, .SCISSOR }),
			dynamicStateCount = 2,
		},
	}

	pipeline: vk.Pipeline
	__ensure(
        vk.CreateGraphicsPipelines(device, 0, 1, &pipelineInfo, nil, &pipeline),
		msg = "Failed to create PBR Pipeline"
    )
	if pbr.pipeline != 0 {
		vk.DestroyPipeline(device, pbr.pipeline, nil)
	}
	pbr.pipeline = pipeline

	duration_msec := time.tick_since(start_compile_time)
	fmt.println("Loaded shader in", duration_msec)
}

diagnostics_check :: #force_inline proc(diagnostics: ^slang.IBlob, loc := #caller_location) {
	if diagnostics != nil {
		buffer := slice.bytes_from_ptr(
			diagnostics->getBufferPointer(),
			int(diagnostics->getBufferSize()),
		)
		assert(false, string(buffer), loc)
	}
}

